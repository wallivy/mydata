# 理解范式
---
[理解数据库设计中的范式](http://www.cnblogs.com/ningskyer/articles/5633044.html)，为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在[关系数据库](https://baike.baidu.com/item/关系型数据库/8999831)中这种规则就称为范式。范式是符合某一种设计要求的总结。
要想设计一个结构合理的关系型数据库，必须满足一定的范式。

## 如何开始你的数据库设计？
对于[信息管理](https://baike.baidu.com/item/信息管理/450895?fr=aladdin)类的程序来说，一个系统就是一个[信息库](https://baike.baidu.com/item/信息库/6125433?fr=aladdin)。在大量的信息中为了索引、区别，最好的办法就是用[数据库](https://baike.baidu.com/item/数据库)。然而建立一个简洁、高效、全面的数据库却并不简单。一个优秀的数据库无疑能够帮助程序员减少业务逻辑操作，减少出错的可能性；而一个糟糕的数据库设计会在需要添加功能的时候无从扩展，或是大量的冗余造成性能的瓶颈。因此，建立一个优秀的数据库，设计好每一张表格变成了尤为重要的事情。也许你是拿到任务就开始建立表了，user表、product表等等。一张一张的完成，倒是很有速度也很有成就感，但是这绝对是最差的做法。因为你面向的对象是一个系统，而对付这一个系统的时候，你就需要好好思考了。

对于数据库而言，最简单的理解方式：数据库就是一个系统，表就是它的对象，而字段即是它的属性。一个确保数据库事务正确执行的四个基本要素是：

- 原子性。基本表中的字段是不可再分解的。

- 原始性。基本表中的记录是原始数据（基础数据）的记录。

- 演绎性。由基本表与代码表中的数据，可以派生出所有的输出数据。

- 稳定性。基本表的结构是相对稳定的，表中的记录是要长期保存的。

## 常见设计范式
在实际开发中最为常见的设计范式有三个：

1．[第一范式](https://baike.baidu.com/item/第一范式)(确保每列保持原子性)
- 规定关系
 - 第一范式规定关系的每一个属性必须是一个不可分的数据项。
 - 几乎所有的商用关系DBMS都要求关系为第一范式，现在流行的关系数据库语言，如SQL，也都只支持第一范式。
 - 如果关系仅仅满足第一范式的条件是不够的，可能会存在更新异常。为了消除这些异常，需要进行关系的规范化。

- 指导原则：
 - 关系中每个记录的每个属性只能包含一个值；
 - 关系中的每个记录必须包含相同数量的值；
 - 关系中的每个记录一定不能相同。
 - 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。
 - 但是满足第一范式的关系模式并不一定是一个好的关系模式。

2．[第二范式](https://baike.baidu.com/item/第二范式)(确保表中的每列都和主键相关)

第二范式(Second Normal Form,2nd NF)是指每个表必须有一个(而且仅有一个)数据元素为主关键字(Primary key),其他数据元素与主关键字一一对应。通常称这种关系为函数依赖(Functional dependence)关系，即表中其他数据元素都依赖于主关键字,或称该数据元素惟一地被主关键字所标识。第二范式是数据库规范化中所使用的一种正规形式。它的规则是要求数据表里的所有非主属性都要和该数据表的主键有完全依赖关系；如果有哪些非主属性只和主键的一部份有关的话，它就不符合第二范式。同时可以得出：如果一个数据表的主键只有单一一个字段的话，它就一定符合第二范式(前提是该数据表符合第一范式)。

3．[第三范式](https://baike.baidu.com/item/第三范式)(确保每列都和主键列直接相关,而不是间接相关)

第三范式(Third Normal Form,3rd NF)就是指表中的所有数据元素不但要能惟一地被主关键字所标识,而且它们之间还必须相互独立,不存在其他的函数关系。也就是说，对于一个满足2nd NF 的数据结构来说，表中有可能存在某些数据元素依赖于其他非关键字数据元素的现象(传递函数依赖),必须消除。

将第一范式，第二范式化为第三范式的步骤：

- 求出R的最小函数依赖集Fmin
- 找出不在Fmin中出现的属性，并将这些属性从R中去掉，构成一个关系模式
- 若Fmin中有一个函数依赖涉及R的全部属性，则R不能分解
- 否则，若Fmin中有X->A,则分解应包含{XA};若有X->A1,X->A2....X->An均属于Fmin，则分解应包含{XA1A2...An}

## 理解[函数依赖](https://baike.baidu.com/item/函数依赖)

概念
1. 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。
2. 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。
例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立
3. 数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。

属性关系

属性之间有三种关系，但并不是每一种关系都存在函数依赖。设R(U)是属性集U上的关系模式，X、Y是U的子集：

- 如果X和Y之间是1：1关系（一对一关系），如学校和校长之间就是1:1关系，则存在函数依赖X → Y和Y →X。
- 如果X和Y之间是1：n关系（一对多关系），如年龄和姓名之间就是1:n关系，则存在函数依赖Y → X。
- 如果X和Y之间是m：n关系（多对多关系），如学生和课程之间就是m:n关系，则X和Y之间不存在函数依赖。

## [五大范式所解决的问题及说明](http://blog.sina.com.cn/s/blog_a637e97e0101321t.html)
范式在现实中解决的问题
- 数据冗余：所谓数据冗余，是指一个表中的一个或多个属性发生改变的时候，会出现多个或更多的属性的数据重复出现。也就是说，属性与属性之间、属性与属性组之间或者属性组与属性组之间存在着一对多或者多对多的数据关系。
- 插入异常：所谓插入异常，是指某个属性，特别是主键，为空，则尽管其他的属性有数据，也无法插入。
- 删除异常：所谓删除异常，是指由于某个原因，需要删除表中的某些没用的属性，但是同时也会把其他的一些有用的属性的数据也同时删除掉。
- 更新异常：所谓更新异常，是指如果某个属性的数据发生改变的时候，就需要对应属性修改很多的数据。

[数据库范式问题](https://blog.csdn.net/weichi7549/article/details/79688025)及实例

- 判断的方法是：

  第一步：找出数据表中所有的码。

  第二步：根据第一步所得到的码，找出所有的主属性。

  第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。

  第四步：查看是否存在非主属性对码的部分函数依赖。

[上一篇：为什么学习Access]()  [下一篇：数据库规范化]()
